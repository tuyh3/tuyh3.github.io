<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基本操作命令</title>
      <link href="/2021/11/21/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/21/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h1><pre><code class="shell"># 查看所有 topic./bin/kafka-topics.sh --zookeeper 192.168.20.185:2181 --list# 查看指定 topic 的详细信息./bin/kafka-topics.sh --describe --zookeeper 192.168.20.185:2181 --topic METRIC_G1_TOPIC# 创建 topic./bin/kafka-topics.sh --create --zookeeper 192.168.20.185:2181 --replication-factor 1 --partitions 3 --topic METRIC_G1_TOPIC# 调用生产者./bin/kafka-console-producer.sh --broker-list 192.168.20.185:9092 --topic METRIC_G1_TOPIC# 调用消费者./bin/kafka-console-consumer.sh --bootstrap-server 192.168.20.185:9092 --topic  METRIC_G1_TOPIC  --from-beginning # 删除 topic./bin/kafka-topics.sh --zookeeper 192.168.20.185:2181 --delete --topic METRIC_G1_TOPIC</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QuartZ Cron表达式 / QuartZ定时任务</title>
      <link href="/2021/11/18/QuartZ-Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F-QuartZ%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2021/11/18/QuartZ-Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F-QuartZ%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="QuartZ-Cron表达式-QuartZ定时任务（Spring-实现）"><a href="#QuartZ-Cron表达式-QuartZ定时任务（Spring-实现）" class="headerlink" title="QuartZ Cron表达式 / QuartZ定时任务（Spring 实现）"></a>QuartZ Cron表达式 / QuartZ定时任务（Spring 实现）</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>[TOC]</p><p>cron 表达式用于配置 cronTrigger 的实例。cron 表达式实际上是由七个子表达式组成。这些表达式之间用空格分隔。</p><ol><li>Seconds（秒）</li><li>Minutes（分）</li><li>Hours（小时）</li><li>Day-of-Month（天）</li><li>Month（月）</li><li>Day-of-Week（周）</li><li>Year（年）</li></ol><p>例：”0 0 12 ? * WED” 意思是：每个星期三的中午12点执行。</p><p>个别子表达式可以包含范围或者列表。例如：上面例子中的WED可以换成 “MON-FRI”，”MON,WED,FRI”，甚至 “MON-WED,SAT”。</p><p><strong>子表达式范围：</strong></p><ol><li>Seconds  (0~59)</li><li>Minutes  (0~59)</li><li>Hours  (0~23)</li><li>Day-of-Month (1~31，但是要注意有些月份没有31天)</li><li>Month  (0~11，或者 “ JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV,DEC “)</li><li>Day-of-Week  (1~7,1=SUN 或者 “ SUN, MON, TUE, WED, THU, FRI, SAT “)</li><li>Year  (1970~2099)</li></ol><p>Cron 表达式的格式：秒 分 时 日 月 周 年(可选)。</p><table><thead><tr><th>字段名</th><th>允许的值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0 - 59</td><td>, - * /</td></tr><tr><td>分</td><td>0 - 59</td><td>, - * /</td></tr><tr><td>小时</td><td>0 - 23</td><td>, - * /</td></tr><tr><td>日</td><td>1 - 31</td><td>, - * ? / L W C</td></tr><tr><td>月</td><td>1 - 12 or JAN - DEC</td><td>, - * /</td></tr><tr><td>周几</td><td>1 - 7 or SUN - SAT</td><td>, - * ? / L C #</td></tr><tr><td>年（可选字段）</td><td>empty</td><td>1970 - 2099 , - * /</td></tr></tbody></table><p><strong>字符含义：</strong></p><p>***** ：代表所有可能的值。因此，“*” 在 Month 中表示每个月，在 Day-of-Month 中表示每天，在 Hours 表示每小时</p><p><strong>-</strong> ：表示指定范围。</p><p><strong>,</strong> ：表示列出枚举值。例如：在 Minutes 子表达式中，“5,20” 表示在 5 分钟和 20 分钟触发。</p><p><strong>/</strong> ：被用于指定增量。例如：在 Minutes 子表达式中，“0/15” 表示从0分钟开始，每 15 分钟执行一次。“3/20” 表示从第三分钟开始，每 20 分钟执行一次。和 “3,23,43” （表示第 3,23,43 分钟触发）的含义一样。</p><p><strong>?</strong> ：用在 Day-of-Month 和 Day-of-Week 中，指 “没有具体的值”。当两个字表达式其中一个指定了值以后，为了避免冲突，需要将另一个值设为 “?”。例如：想在每月 20 日触发调度，不管 20 号是星期几，只能用如下写法：0 0 0 20 * ?，其中最后只能用 “？”，而不能用 “*”。</p><p><strong>L</strong>：用在 day-of-month 和 day-of-week 子串中。它是单词 “last” 的缩写。它在两个子表达式中的含义是不同的。</p><p>​      在 day-of-week 中，“L” 表示一个月的最后一天，如：1月31号，3月30号。</p><p>​      在 day-of-week 中，“L” 表示一个星期的最后一天，也就是 “7” 或 ”SAT“</p><p>​      如果 ”L“ 前有具体内容，他就有其他的含义了。例如：”6L“ 表示这个月的倒数第六天。”FRIL“ 表示这个月的最后一个星期五。</p><p>​     注意：在使用 “L” 参数时，不要指定列表或者范围，这样会出现问题。</p><p><strong>W</strong>：“Weekday” 的缩写。只能用在 day-of-month 字段。用来描述最接近指定天的工作日（周一到周五）。例如：在 day-of-month 字段用 “15W”  指 “最接近这个月第 15 天的工作日”，即如果这个月第 15 天是周六，那么触发器将会在这个月第 14 天即周五触发；如果这个月第 15 天是周日，那么触发器将会在这个月第 16 天即周一触发；如果这个月第 15 天是周二，那么久在触发器这天触发。<strong>注意一点：</strong>这个用法只会在当前月计算值，不会越过当前月。“W” 字符仅能在 day-of-month 指明一天，不能是一个范围或列表。也可以用 “LW” 来指定这个月的最后一个工作日，即最后一个星期五。</p><p>**#**：只能用在 day-of-week 字段。用来描述最接近指定天的工作日（周一到周五）。例如：在 day-of-month 字段用 “6#3” or “FRI#3” 指定这个月第三个周五（6指周五，3指第三个）。如果指定的日期不存在，触发器就不会触发。</p><p><strong>表达式例子：</strong></p><p>0 * * * * ?    每 1 分钟触发一次</p><p>0 0 * * * ?    每天每 1 小时触发一次</p><p>0 0 10 * * ?    每天 10 点触发一次</p><p>0 * 14 * * ?    在每天下午2点到下午2:59期间的每1分钟触发 </p><p>0 30 9 1 * ?    每月1号上午9点半</p><p>0 15 10 15 * ?    每月15日上午10:15触发</p><p>*/5 * * * * ?    每隔5秒执行一次</p><p>0 */1 * * * ?    每隔1分钟执行一次</p><p>0 0 5-15 * * ?    每天5-15点整点触发</p><p>0 0/3 * * * ?    每三分钟触发一次</p><p>0 0-5 14 * * ?    在每天下午2点到下午2:05期间的每1分钟触发 </p><p>0 0/5 14 * * ?    在每天下午2点到下午2:55期间的每5分钟触发</p><p>0 0/5 14,18 * * ?    在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</p><p>0 0/30 9-17 * * ?    朝九晚五工作时间内每半小时</p><p>0 0 10,14,16 * * ?    每天上午10点，下午2点，4点 </p><p>0 0 12 ? * WED    表示每个星期三中午12点</p><p>0 0 17 ? * TUES,THUR,SAT    每周二、四、六下午五点</p><p>0 10,44 14 ? 3 WED    每年三月的星期三的下午2:10和2:44触发 </p><p>0 15 10 ? * MON-FRI    周一至周五的上午10:15触发</p><p>0 0 23 L * ?    每月最后一天23点执行一次</p><p>0 15 10 L * ?    每月最后一日的上午10:15触发 </p><p>0 15 10 ? * 6L    每月的最后一个星期五上午10:15触发</p><p>0 15 10 * * ? 2005    2005年的每天上午10:15触发 </p><p>0 15 10 ? * 6L 2002-2005    2002年至2005年的每月的最后一个星期五上午10:15触发 </p><p>0 15 10 ? * 6#3    每月的第三个星期五上午10:15触发</p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 时间格式</title>
      <link href="/2021/11/18/Linux-%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/"/>
      <url>/2021/11/18/Linux-%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-时间格式"><a href="#Linux-时间格式" class="headerlink" title="Linux 时间格式"></a>Linux 时间格式</h1><pre><code class="shell">date +%Y-%m-%d-%H-%M-%S</code></pre><p>结果：</p><pre><code class="shell">2021-02-03-04-00-01年-月-日-时-分-秒</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下删除文件中 ^M 乱码</title>
      <link href="/2021/11/18/Linux%E4%B8%8B%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E4%B8%AD%5EM%E4%B9%B1%E7%A0%81/"/>
      <url>/2021/11/18/Linux%E4%B8%8B%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E4%B8%AD%5EM%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-下删除文件中-M-乱码"><a href="#Linux-下删除文件中-M-乱码" class="headerlink" title="Linux 下删除文件中 ^M 乱码"></a>Linux 下删除文件中 ^M 乱码</h1><blockquote><p> 在 Linux 下使用 vi 来查看一些在 Windows 下创建的文本文件，有时会发现在行尾有一些 “^M”</p></blockquote><p><strong>去掉 ^M 方法：</strong></p><pre><code class="shell">1. dos2unix 文件2. sed -i &quot;s=^M==g&quot; 文件3. vim 一般模式使用 :%s/^M//g</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下删除文件中 $&lt;$feff$&gt;$​ 乱码</title>
      <link href="/2021/11/18/Linux%E4%B8%8B%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E4%B8%ADfeff%E4%B9%B1%E7%A0%81/"/>
      <url>/2021/11/18/Linux%E4%B8%8B%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E4%B8%ADfeff%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-下删除文件中-lt-feff-gt-​-乱码"><a href="#Linux-下删除文件中-lt-feff-gt-​-乱码" class="headerlink" title="Linux 下删除文件中 $&lt;$feff$&gt;$​ 乱码"></a>Linux 下删除文件中 $&lt;$feff$&gt;$​ 乱码</h1><blockquote><p>linux下处理windows utf8文件，发现vim头会多一个 <feff></p></blockquote><h2 id="linux-vim-中的-lt-​feff-gt"><a href="#linux-vim-中的-lt-​feff-gt" class="headerlink" title="linux  vim 中的 $&lt;$​feff$&gt;$"></a>linux  vim 中的 $&lt;$​feff$&gt;$</h2><p>$&lt;$​feff$&gt;$​​ 称作 BOM（Byte Order Mark）的不可见字符，是 Unicode 用来标识内部编码的排列方式的，在 UTF-16、UTF-32 编码里它是必需的，而在 UTF-8 里是可选的。</p><p><strong>删除方法：</strong></p><pre><code class="shell">grep -I -r -l $&#39;\xEF\xBB\xBF&#39;  文件 | xargs sed  -i  &#39;s/\xEF\xBB\xBF//’</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux启动程序报错：$&#39;r&#39;未找到命令</title>
      <link href="/2021/11/18/Linux%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99%EF%BC%9A$&#39;r&#39;%E6%9C%AA%E6%89%BE%E5%88%B0%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/18/Linux%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99%EF%BC%9A$&#39;r&#39;%E6%9C%AA%E6%89%BE%E5%88%B0%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="linux启动程序报错：-’r’未找到命令"><a href="#linux启动程序报错：-’r’未找到命令" class="headerlink" title="linux启动程序报错：$’r’未找到命令"></a>linux启动程序报错：$’r’未找到命令</h1><p>因为在dos/window下按一次回车键实际上输入的是“回车（CR)”和“换行（LF）”，而Linux/unix下按一次回车键只输入“换行（LF）”，所以文件在每行都会多了一个CR，所以Linux下运行时就会报错找不到命令，所以，解决问题之道，就是把dos文件格式转换为unix格式</p><p><strong>方法1：使用dos2unix命令转换</strong></p><p>第一步：安装dos2unix命令，如果已经安装，跳过该步骤</p><pre><code class="shell"># centosyum install dos2unix# ubuntusudo apt-get install dos2unix</code></pre><p>第二步：转换格式</p><pre><code class="shell"> dos2unix /usr/apache-tomcat/bin/restart.sh #  dos2unix /usr/apache-tomcat/bin/restart.sh</code></pre><p><strong>方法2：使用notepad++</strong></p><p>在windows系统下使用notepad++编辑该sh文件，双击文件右下角编码区域选择”转换为UNIX格式”，如下图： </p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux定义环境变量[export命令]</title>
      <link href="/2021/11/18/Linux%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2021/11/18/Linux%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux定义环境变量-export命令"><a href="#Linux定义环境变量-export命令" class="headerlink" title="Linux定义环境变量[export命令]"></a>Linux定义环境变量[export命令]</h1><p>修改/etc/profile文件</p><p><strong>基本语法：</strong>export [-fnp] [变量名称]=[变量设置值]</p><p><strong>参数说明：</strong></p><p>-f：代表[变量名称]中函数名称。</p><p>-n：删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。</p><p>-p：列出所有的shell赋予程序的环境变量。</p><p><strong>实例：</strong></p><pre><code class="shell">cat &gt; /etc/profile.d/java.sh &lt;&lt; EOFJAVA_HOME=/opt/jdk1.8.0_192PATH=\$JAVA_HOME/bin:\$PATHexport JAVA_HOMEEOF</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux批量ping脚本</title>
      <link href="/2021/11/18/Linux%E6%89%B9%E9%87%8Fping%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/11/18/Linux%E6%89%B9%E9%87%8Fping%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux批量ping脚本"><a href="#Linux批量ping脚本" class="headerlink" title="Linux批量ping脚本"></a>Linux批量ping脚本</h1><pre><code class="shell">vi ping_ip.sh#! /bin/bash#功能，ping文件ip.lst中的IP，成功的输出到ping_ok.lst文件，失败的输出到ping_fail.lst文件。echo &quot;&quot; &gt;ping_fail.lst    # 先初始化下两个结果文件，避免多次执行的时候数据混乱问题echo &quot;&quot; &gt;ping_ok.lstfor i in `cat ip.lst`    # for 循环 ip.lst 这个文件，  这也可以改改 ，比如 cat iplst |grep -v ^# 将 “#” 开头的行去掉。 do    # 执行 ping 命令将 ping 的结果放到变量 ping 中，成功的返回的是 0，失败的返回的是 100     ping=`ping -c 1 $i|grep loss|awk &#39;&#123;print $6&#125;&#39;|awk -F &quot;%&quot; &#39;&#123;print $1&#125;&#39;`    if [ $ping -eq 100 ];then        echo  $i &gt;&gt;ping_fail.lst    else        echo $i &gt;&gt;ping_ok.lst    fidone </code></pre><p>ip 文件案例：</p><pre><code>ip.lst 10.1.1.110.2.4.8</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 查看操作防火墙方法</title>
      <link href="/2021/11/18/Linux%E6%9F%A5%E7%9C%8B%E6%93%8D%E4%BD%9C%E9%98%B2%E7%81%AB%E5%A2%99%E6%96%B9%E6%B3%95/"/>
      <url>/2021/11/18/Linux%E6%9F%A5%E7%9C%8B%E6%93%8D%E4%BD%9C%E9%98%B2%E7%81%AB%E5%A2%99%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-查看操作防火墙方法"><a href="#Linux-查看操作防火墙方法" class="headerlink" title="Linux 查看操作防火墙方法"></a>Linux 查看操作防火墙方法</h1><h3 id="具体操作步骤"><a href="#具体操作步骤" class="headerlink" title="具体操作步骤"></a>具体操作步骤</h3><p>1、在 centos 系统桌面中使用快捷键【Ctrl+Alt+T】打开终端命令行模式。</p><p>2、在 centos 终端命令行中输入以下命令查看防火墙状态即可。</p><pre><code class="shell"># 查看 iptables 防火墙状态service iptables status#查看 firewall 防火墙服务状态systemctl status firewalld</code></pre><h3 id="相关操作命令"><a href="#相关操作命令" class="headerlink" title="相关操作命令"></a>相关操作命令</h3><h4 id="iptables防火墙"><a href="#iptables防火墙" class="headerlink" title="iptables防火墙"></a>iptables防火墙</h4><pre><code class="shell"># 启动防火墙service iptables start# 停止防火墙service iptables stop# 重启防火墙service iptables restart</code></pre><h4 id="firewall-防火墙"><a href="#firewall-防火墙" class="headerlink" title="firewall 防火墙"></a>firewall 防火墙</h4><pre><code class="shell"># 开启service firewalld start# 关闭 service firewalld stop # 重启service firewalld restart </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux磁盘情况查询</title>
      <link href="/2021/11/18/Linux%E7%A3%81%E7%9B%98%E6%83%85%E5%86%B5%E6%9F%A5%E8%AF%A2/"/>
      <url>/2021/11/18/Linux%E7%A3%81%E7%9B%98%E6%83%85%E5%86%B5%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux磁盘情况查询"><a href="#Linux磁盘情况查询" class="headerlink" title="Linux磁盘情况查询"></a>Linux磁盘情况查询</h1><p><strong>基本语法：</strong>df -h</p><p><strong>参数：</strong></p><p>-s：指定目录占用大小汇总</p><p>-h：带计量单位</p><p>-a：含文件</p><p>–max-depth=1：子目录深度</p><p>-c：列出明细的同时，增加汇总值</p><p><strong>工作实用指令：</strong></p><p>（1）统计 /opt 文件夹下文件的个数</p><pre><code class="shell">ls -l /opt | grep &quot;^-&quot; | wc -l</code></pre><p>（2）统计 /opt 文件夹下目录的个数</p><pre><code class="shell">ls -l /opt | grep &quot;^d&quot; | wc -l</code></pre><p>（3）统计 /opt 文件夹下文件的个数，包括子文件夹里的</p><pre><code class="shell">ls -lR /opt | grep &quot;^-&quot; | wc -l</code></pre><p>（4）统计 /opt 文件夹下目录的个数，包括子文件夹里的 </p><pre><code class="shell">ls -lR /opt | grep &quot;^d&quot; | wc -l</code></pre><p>（5）以树状显示目录结构 tree 目录，注意，如果没有 tree，则使用 yum install tree 安装</p><p><img src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210719223712280.png" alt="image-20210719223712280"></p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：EOF （自定义终止符）用法</title>
      <link href="/2021/11/18/Linux%EF%BC%9AEOF%E7%94%A8%E6%B3%95/"/>
      <url>/2021/11/18/Linux%EF%BC%9AEOF%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：EOF-（自定义终止符）用法"><a href="#Linux：EOF-（自定义终止符）用法" class="headerlink" title="Linux：EOF （自定义终止符）用法"></a>Linux：EOF （自定义终止符）用法</h1><blockquote><p>在平时的运维工作中，我们经常会碰到这样一个场景：执行脚本的时候，需要往一个文件里自动输入N行内容。如果是少数的几行内容，还可以用echo追加方式，但如果是很多行，那么单纯用echo追加的方式就显得愚蠢之极了！<strong>这个时候，就可以使用EOF结合cat命令进行行内容的追加了。</strong></p></blockquote><p>EOF 是 END Of File 的缩写，表示自定义终止符。既然自定义,那么 EOF 就不是固定的,可以随意设置别名。在 Linux 按 ctrl+d 就代表 EOF。</p><p>EOF 一般会配合 cat 能够多行文本输出。其用法如下：</p><pre><code class="shell">&lt;&lt; EOF    # 开始...EOF    # 结束</code></pre><p>还可以自定义，比如自定义：</p><pre><code class="shell">&lt;&lt; BBB    # 开始...BBB    # 结束</code></pre><p>注：EOF 不是固定的，可以自定义其他，但需注意，结束符和起始符要保持一致</p><p><strong>重定向符号</strong></p><pre><code class="shell">&lt; :输入重定向&gt; :输出重定向&gt;&gt; :输出重定向,追加,不覆盖之前内容&lt;&lt; :标准输入来自命令行的一对分隔号的中间内容</code></pre><p><strong>下面是 cat 结合 EOF 使用示例：</strong></p><pre><code class="shell"># 向文件 test.sh 里输入内容cat &lt;&lt; EOF &gt;test.sh 1231231233452354345asdfasdfsEOF# 向文件 test.sh 里追加内容cat &lt;&lt; EOF &gt;&gt;test.sh 77778888EOF# 覆盖 test.sh 文件cat &lt;&lt; EOF &gt;test.sh55555EOF# 编写脚本，向一个文件输出多行内容touch /usr/local/mysql/my.cnfvim test.shcat &gt; /usr/local/mysql/my.cnf &lt;&lt; EOF    # 或者cat &lt;&lt; EOF &gt; /usr/local/mysql/my.cnf[client]port = 3306socket = /usr/local/mysql/var/mysql.sock[mysqld]port = 3306socket = /usr/local/mysql/var/mysql.sockbasedir = /usr/local/mysql/datadir = /data/mysql/datapid-file = /data/mysql/data/mysql.piduser = mysqlbind-address = 0.0.0.0server-id = 1sync_binlog=1log_bin = mysql-bin[myisamchk]key_buffer_size = 8Msort_buffer_size = 8Mread_buffer = 4Mwrite_buffer = 4Msql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES port = 3306EOF</code></pre><p><strong>思考：</strong><br>我们可以从cat命令的说明中知道，cat的操作对象是文件，但是例1中cat的操作对象不是文件，而是用户输入。</p><p>那么我们可以这样理解例1：先在文件file中输入“Hello”，再用cat file输出其中的内容。<br>也就是说我们可以用一个文件来替代”&lt;&lt; EOF EOF”。<br>反过来说，如果操作命令中的文件是输入对象，也可以用”&lt;&lt; EOF EOF”来替代的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk入门教程</title>
      <link href="/2021/11/18/Linux%EF%BC%9Aawk%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2021/11/18/Linux%EF%BC%9Aawk%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="awk入门教程"><a href="#awk入门教程" class="headerlink" title="awk入门教程"></a>awk入门教程</h1><p>awk 是处理文本文件的一个应用程序，几乎所有 Linux 系统都自带这个程序。</p><p>它依次处理文件的每一行，并读取里面的每一个字段。对于<strong>日志</strong>、<strong>csv</strong> 这样的每行格式相同的文本文件，awk 可能是最方便的工具。</p><p>awk 其实不仅仅是工具软件，还是一种编程语言。不过，本文只介绍它的命令用法，对于大多数场合，应该足够了。</p><h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><p>awk的基本用法如下：</p><pre><code class="shell"># 格式awk 动作 文件名# 实例awk &#39;&#123;print $0&#125;&#39; demo.txt</code></pre><p>上面示例中，demo.txt是awk要处理的文本文件。前面单引号内部有一个大括号，里面就是每一行的处理动作<code>print $0</code>。其中，print是打印命令，<code>$0</code>代表当前行，因此上面命令的执行结果，就是把每一行原样打印出来。</p><p>下面，我们先用标准输入（stdin）演示上面这个例子。</p><pre><code class="shell">echo &#39;this is a test&#39; | awk &#39;&#123;print $0&#125;&#39;# 结果this is a test</code></pre><p>上面代码中，print $0就是把标准输入this is a test，重新打印了一遍。</p><p>awk会根据空格和制表符，将每一行分成若干段，一次用<code>$1</code>、<code>$2</code>、<code>$3</code>代表第一个字段、第二个字段、第三个字段等等。</p><pre><code class="shell">echo &#39;this is a test&#39; | awk &#39;&#123;print $3&#125;&#39;# 结果a</code></pre><p>上面代码中，<code>$3</code>代表this is a test的第三个字段a。</p><p>下面，为了便于举例，我们把/etc/passwd文件保存成demo.txt。</p><pre><code class="txt">root:x:0:0:root:/root:/usr/bin/zshdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/sync</code></pre><p>这个文件的字段分隔符号是（：），所以要用-F参数指定分隔符为冒号。然后，才能提取到它的第一个字段。</p><pre><code class="shell">awk -F &#39;:&#39; &#39;&#123; print $1 &#125;&#39; demo.txt# 结果rootdaemonbinsyssync</code></pre><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><p>除了<code>$</code>、<code>+</code>、<code>数字</code>表示某个字段，<code>awk</code>还提供其他一些变量。</p><p>变量NF表示当前有多少个字段，因此<code>$NF</code>就代表最后一个字段。</p><pre><code class="shell">echo &#39;this is a test&#39; | awk &#39;&#123;print $NF&#125;&#39;# 结果test</code></pre><p>$(NF-1)代表倒数第二个字段。</p><pre><code class="shell">awk -F &#39;:&#39; &#39;&#123;print $1, $(NF-1)&#125;&#39; demo.txt# 结果root /rootdaemon /usr/sbinbin /binsys /devsync /bin</code></pre><p>上面代码中，<code>print</code>命令里面的逗号，表示输出的时候，两个部分之间使用空格分隔。</p><p>变量<code>NR</code>表示当前处理的是第几行。</p><pre><code class="shell">awk -F &#39;:&#39; &#39;&#123;print NR &quot;) &quot; $1&#125;&#39; demo.txt# 结果1) root2) daemon3) bin4) sys5) sync</code></pre><p>上面代码中，<code>print</code>命令里面，如果原样输出字符，要放在双引号里面。</p><p>awk的其他内置变量如下。</p><ul><li><code>FILENAME</code>：当前文件名</li><li><code>FS</code>：字段分隔符，默认是空格和制表符。</li><li><code>RS</code>：行分隔符，用于分割每一行，默认是换行符。</li><li><code>OFS</code>：输出字段的分隔符，用于打印时分隔字段，默认为空格。</li><li><code>ORS</code>：输出记录的分隔符，用于打印时分隔记录，默认为换行符。</li><li><code>OFMT</code>：数字输出的格式，默认为<code>％.6g</code>。</li></ul><h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><p><code>awk</code>还提供了一些内置函数，方便对原始数据的处理。</p><p>函数<code>toupper()</code>用于将字符转换为大写。</p><pre><code class="shell">awk -F &#39;:&#39; &#39;&#123; print toupper($1) &#125;&#39; demo.txt# 结果ROOTDAEMONBINSYSSYNC</code></pre><p>上面代码中，第一个字段输出时都变成了大写。</p><p>其他常用函数如下：</p><ul><li><code>tolower()</code>：字符转为小写。</li><li><code>length()</code>：返回字符串长度。</li><li><code>substr()</code>：返回子字符串。</li><li><code>sin()</code>：正弦。</li><li><code>cos()</code>：余弦。</li><li><code>sqrt()</code>：平方根。</li><li><code>rand()</code>：随机数。</li></ul><p><code>awk</code>内置函数的完整列表，可以查看<a href="https://www.gnu.org/software/gawk/manual/html_node/Built_002din.html#Built_002din">手册</a>。</p><h2 id="四、条件"><a href="#四、条件" class="headerlink" title="四、条件"></a>四、条件</h2><p><code>awk</code>允许指定输出条件，只输出符合条件的行。</p><p>输出条件要写在动作的前面。</p><pre><code class="shell">awk &#39;条件 动作&#39; 文件名</code></pre><p>请看下面的例子。</p><pre><code class="shell">awk -F &#39;:&#39; &#39;/usr/ &#123;print $1&#125;&#39; demo.txt# 结果rootdaemonbinsys</code></pre><p>上面代码中，<code>print</code>命令前面是一个正则表达式，只输出包含<code>usr</code>的行。</p><p>下面的例子只输出奇数行，以及输出第三行以后的行。</p><pre><code class="shell"># 输出奇数行$ awk -F &#39;:&#39; &#39;NR % 2 == 1 &#123;print $1&#125;&#39; demo.txt# 结果rootbinsync# 输出第三行以后的行$ awk -F &#39;:&#39; &#39;NR &gt;3 &#123;print $1&#125;&#39; demo.txt# 结果syssync</code></pre><p>下面的例子输出的第一个字段等于指定的行。</p><pre><code class="shell">awk -F &#39;:&#39; &#39;$1 == &quot;root&quot; &#123;print $1&#125;&#39; demo.txt# 结果rootawk -F &#39;:&#39; &#39;$1 == &quot;root&quot; || $1 == &quot;bin&quot; &#123;print $1&#125;&#39; demo.txt# 结果rootbin</code></pre><h2 id="五、if语句"><a href="#五、if语句" class="headerlink" title="五、if语句"></a>五、if语句</h2><p><code>awk</code>提供了<code>if</code>结构，用于编写复杂的条件。</p><pre><code class="shell">awk -F &#39;:&#39; &#39;&#123;if ($1 &gt; &quot;m&quot;) print $1&#125;&#39; demo.txt# 结果rootsyssync</code></pre><p>上面代码输出第一个字段的第一个字符大于m的行。</p><p><code>if</code>结构还可以指定<code>else</code>部分。</p><pre><code class="shell">$ awk -F &#39;:&#39; &#39;&#123;if ($1 &gt; &quot;m&quot;) print $1; else print &quot;---&quot;&#125;&#39; demo.txt# 结果root------syssync</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：awk 命令详解</title>
      <link href="/2021/11/18/Linux%EF%BC%9Aawk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/11/18/Linux%EF%BC%9Aawk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：awk-命令详解"><a href="#Linux：awk-命令详解" class="headerlink" title="Linux：awk 命令详解"></a>Linux：awk 命令详解</h1><p>特点：取列，统计计算</p><p>场景：主要用来取列；对比，比较；统计，计算（awk 数组）</p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：file命令详解</title>
      <link href="/2021/11/18/Linux%EF%BC%9Afile%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/11/18/Linux%EF%BC%9Afile%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：file命令详解"><a href="#Linux：file命令详解" class="headerlink" title="Linux：file命令详解"></a>Linux：file命令详解</h1><blockquote><p>file：用于辨识文件类型，通过<code>file</code>命令，我们可以识别该文件的类型</p></blockquote><p><strong>语法：</strong></p><pre><code class="shell">file [-bcLvz] [-f &lt;名称文件&gt;] [-m &lt;魔法数字文件&gt;...][文件或目录...]</code></pre><p><strong>参数：</strong></p><pre><code class="shell">-b 　列出辨识结果时，不显示文件名称。-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。-L 　直接显示符号连接所指向的文件的类别。-m&lt;魔法数字文件&gt; 　指定魔法数字文件。-v 　显示版本信息。-z 　尝试去解读压缩文件的内容。[文件或目录...] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</code></pre><p><strong>实例：</strong></p><pre><code class="shell">file $SHELL    #查看处理器是X86还是ARM架构的</code></pre><pre><code class="shell">file /test/file -b /test/  # 不显示文件名称file -i /test/  # 显示MIME类别file -b -i /test/</code></pre><pre><code class="shell">touch file.txt  # 创建测试文件ln -s file.txt file_soft_link  # 设置软连接文件file file_soft_linkll file -L file_soft_link  # empty是空的意思，内面没有内容file file.txt file -L file.txt echo &quot;I Love Linux&quot;  &gt; file.txt  # 添加内容，再次查看cat file.txt file file.txt file -L file.txt </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：grep 命令详解</title>
      <link href="/2021/11/18/Linux%EF%BC%9Agrep%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/11/18/Linux%EF%BC%9Agrep%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：grep-命令详解"><a href="#Linux：grep-命令详解" class="headerlink" title="Linux：grep 命令详解"></a>Linux：grep 命令详解</h1><blockquote><p><strong>特点：</strong>过滤</p><p><strong>场景：</strong>grep 命令过滤速度是最快的</p></blockquote><h2 id="常用参数-选项"><a href="#常用参数-选项" class="headerlink" title="常用参数[选项]"></a>常用参数[选项]</h2><pre><code class="shell">-E    # 相当于egrep，支持扩展正则-c    # 统计出现了多少行，类似于 wc -l-v        :&lt;&lt;!          取反，排除（一般与 -c 一起用）；         因为ps + grep的时候容易把自己也过滤出来，容易导致 判断进程状态失误；             [注：常用写法如：ps -ef | grep crond | grep -v grep          或 ps -ef | grep crond | grep -v grep | wc -l]         另一种精简方法：ps -ef | grep &#39;[c]rond&#39;    [注：在要排除的单词中任意一个字母上加中括号]         原因：grep 执行的时候，进程名字 grep &#39;[c]rond&#39;，         但是 grep 实际匹配的时候，进程名字 grep &#39;crond&#39;，         通过这样的特点，巧妙的排除了 grep 命令的进程    !-n    # 显示行号-i    # 过滤的时候忽略大小写-w    # 精确匹配，多用于过滤进程    :&lt;&lt;!        精确匹配的几种写法举例：        echo alibaba ali alihaha alimama | grep -w ali    # 主要用        echo alibaba ali alihaha alimama | grep &#39;\bali\b&#39;        echo alibaba ali alihaha alimama | grep &#39;\&lt;ali\&gt;&#39;    !</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：ldd命令详解</title>
      <link href="/2021/11/18/Linux%EF%BC%9Aldd%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/11/18/Linux%EF%BC%9Aldd%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：ldd命令详解"><a href="#Linux：ldd命令详解" class="headerlink" title="Linux：ldd命令详解"></a>Linux：ldd命令详解</h1><blockquote><p>ldd：用于打印程序或者库文件所依赖的共享库列表</p></blockquote><p><strong>语法：</strong></p><pre><code class="shell">ldd &lt;选项&gt; &lt;参数&gt;</code></pre><p><strong>选项：</strong></p><pre><code class="shell">--version：打印指令版本号；-v：详细信息模式，打印所有相关信息；-u：打印未使用的直接依赖；-d：执行重定位和报告任何丢失的对象；-r：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数；--help：显示帮助信息。</code></pre><p><strong>参数：</strong></p><pre><code class="shell">文件：指定可执行程序或者文库。</code></pre><p><strong>其他介绍：</strong></p><p>（1）ldd不是一个可执行程序，而只是一个shell脚本 ldd能够显示可执行模块的dependency(所属)(所属)，其原理是通过设置一系列的环境变量，如下：LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、LD_VERBOSE等。当LD_TRACE_LOADED_OBJECTS环境变量不为空时，任何可执行程序在运行时，它都会只显示模块的dependency(所属)，而程序并不真正执行。要不你可以在shell终端测试一下，如下： export LD_TRACE_LOADED_OBJECTS=1 再执行任何的程序，如ls等，看看程序的运行结果。</p><p>（2）ldd显示可执行模块的dependency(所属)的工作原理，其实质是通过ld-linux.so（elf动态库的装载器）来实现的。我们知道，ld-linux.so模块会先于executable模块程序工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so选择了显示可执行模块的dependency(所属)。 实际上可以直接执行ld-linux.so模块，如：/lib/ld-linux.so.2 –list program（这相当于ldd program）。</p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：lsof 命令（神器）详解</title>
      <link href="/2021/11/18/Linux%EF%BC%9Alsof%E5%91%BD%E4%BB%A4%EF%BC%88%E7%A5%9E%E5%99%A8%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/11/18/Linux%EF%BC%9Alsof%E5%91%BD%E4%BB%A4%EF%BC%88%E7%A5%9E%E5%99%A8%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：lsof-命令（神器）详解"><a href="#Linux：lsof-命令（神器）详解" class="headerlink" title="Linux：lsof 命令（神器）详解"></a>Linux：lsof 命令（神器）详解</h1><blockquote><p>lsof是系统管理/<a href="http://linuxaria.com/tag/security">安全</a>的尤伯工具。将这个工具称之为lsof真实名副其实，因为它是指“列出打开文件（lists openfiles）”。而有一点要切记，在Unix中一切（包括网络套接口）都是文件。</p></blockquote><h2 id="lsof-关键选项（参数）"><a href="#lsof-关键选项（参数）" class="headerlink" title="lsof 关键选项（参数）"></a>lsof 关键选项（参数）</h2><p>理解一些关于lsof如何工作的关键性东西是很重要的。最重要的是，当你给它传递选项时，默认行为是对结果进行“或”运算。因此，如果你正是用<code>-i</code>来拉出一个端口列表，同时又用<code>-p</code>来拉出一个进程列表，那么默认情况下你会获得两者的结果。</p><p>下面的一些其它东西需要牢记：</p><ul><li>默认 : 没有选项，lsof列出活跃进程的所有打开文件</li><li>组合 : 可以将选项组合到一起，如-abc，但要当心哪些选项需要参数</li><li>-a : 结果进行“与”运算（而不是“或”）</li><li>-l : 在输出显示用户ID而不是用户名</li><li>-h : 获得帮助</li><li>-t : 仅获取进程ID</li><li>-U : 获取UNIX套接口地址</li><li>-F : 格式化输出结果，用于其它命令。可以通过多种方式格式化，如-F pcfn（用于进程id、命令名、文件描述符、文件名，并以空终止）</li></ul><h2 id="获取网络信息"><a href="#获取网络信息" class="headerlink" title="获取网络信息"></a>获取网络信息</h2><p>正如我所说的，我主要将lsof用于获取关于系统怎么和网络交互的信息。这里提供了关于此信息的一些主题：</p><h3 id="使用-i-显示所有连接"><a href="#使用-i-显示所有连接" class="headerlink" title="使用 -i 显示所有连接"></a>使用 <code>-i</code> 显示所有连接</h3><p>有些人喜欢用 <code>netstat</code> 来获取网络连接，但是我更喜欢使用 <code>lsof</code> 来进行此项工作。结果以对我来说很直观的方式呈现，我仅仅只需改变我的语法，就可以通过同样的命令来获取更多信息。</p><p><strong>语法：</strong></p><pre><code class="shell">lsof -i[46] [protocol][@hostname|hostaddr][:service|port]</code></pre><pre><code class="shell">lsof  -i# 示例结果COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAMEdhcpcd 6061 root 4u  IPv4  4510 UDP *:bootpcsshd  7703 root 3u  IPv6  6499 TCP *:ssh  (LISTEN)sshd  7892 root 3u  IPv6  6757 TCP 10.10.1.5:ssh-&gt;192.168.1.5:49901  (ESTABLISHED)</code></pre><h3 id="使用-i-6-仅获取-IPV6-流量"><a href="#使用-i-6-仅获取-IPV6-流量" class="headerlink" title="使用 -i 6 仅获取 IPV6 流量"></a>使用 <code>-i 6</code> 仅获取 IPV6 流量</h3><pre><code class="shell">lsof  -i 6</code></pre><h3 id="显示-TCP-连接（同理可获得-UDP-连接）"><a href="#显示-TCP-连接（同理可获得-UDP-连接）" class="headerlink" title="显示 TCP 连接（同理可获得 UDP 连接）"></a>显示 TCP 连接（同理可获得 UDP 连接）</h3><p>你也可以通过在-i后提供对应的协议来仅仅显示TCP或者UDP连接信息。</p><pre><code class="shell">lsof  -iTCP# 示例结果COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAMEsshd  7703 root 3u  IPv6  6499 TCP *:ssh  (LISTEN)sshd  7892 root 3u  IPv6  6757 TCP 10.10.1.5:ssh-&gt;192.168.1.5:49901  (ESTABLISHED)</code></pre><h3 id="使用-i-port-来显示与指定端口相关的网络信息"><a href="#使用-i-port-来显示与指定端口相关的网络信息" class="headerlink" title="使用 -i:port 来显示与指定端口相关的网络信息"></a>使用 <code>-i:port</code> 来显示与指定端口相关的网络信息</h3><p>或者，你也可以通过端口搜索，这对于要找出什么阻止了另外一个应用绑定到指定端口实在是太棒了。</p><pre><code class="shell">lsof  -i :22# 示例结果COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAMEsshd  7703 root 3u  IPv6  6499 TCP *:ssh  (LISTEN)sshd  7892 root 3u  IPv6  6757 TCP 10.10.1.5:ssh-&gt;192.168.1.5:49901  (ESTABLISHED)</code></pre><h3 id="使用-host-来显示指定到指定主机的连接"><a href="#使用-host-来显示指定到指定主机的连接" class="headerlink" title="使用 @host 来显示指定到指定主机的连接"></a>使用 <code>@host</code> 来显示指定到指定主机的连接</h3><p>这对于你在检查是否开放连接到网络中或互联网上某个指定主机的连接时十分有用。</p><pre><code class="shell">lsof  -i@172.16.12.5# 示例结果sshd  7892 root 3u  IPv6  6757 TCP 10.10.1.5:ssh-&gt;172.16.12.5:49901  (ESTABLISHED)</code></pre><h3 id="使用-host-port-显示基于主机与端口的连接"><a href="#使用-host-port-显示基于主机与端口的连接" class="headerlink" title="使用 @host:port 显示基于主机与端口的连接"></a>使用 <code>@host:port</code> 显示基于主机与端口的连接</h3><p>你也可以组合主机与端口的显示信息。</p><pre><code class="shell">lsof  -i@172.16.12.5:22# 示例结果sshd  7892 root 3u  IPv6  6757 TCP 10.10.1.5:ssh-&gt;172.16.12.5:49901  (ESTABLISHED)</code></pre><h3 id="找出监听端口"><a href="#找出监听端口" class="headerlink" title="找出监听端口"></a>找出监听端口</h3><p>找出正等候连接的端口。</p><pre><code class="shell">lsof  -i -sTCP:LISTEN</code></pre><p>你也可以grep “LISTEN”来完成该任务。</p><pre><code class="shell">lsof  -i |  grep  -i LISTEN# 示例结果iTunes 400 daniel 16u  IPv4  0x4575228  0t0 TCP *:daap (LISTEN)</code></pre><h3 id="找出已建立的连接"><a href="#找出已建立的连接" class="headerlink" title="找出已建立的连接"></a>找出已建立的连接</h3><p>你也可以显示任何已经连接的连接。</p><pre><code class="shell">lsof  -i -sTCP:ESTABLISHED</code></pre><p>你也可以通过grep搜索“ESTABLISHED”来完成该任务。</p><pre><code class="shell">lsof  -i |  grep  -i ESTABLISHED# 示例结果firefox-b 169 daniel 49u  IPv4  0t0 TCP 1.2.3.3:1863-&gt;1.2.3.4:http (ESTABLISHED)</code></pre><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><p>你也可以获取各种用户的信息，以及它们在系统上正干着的事情，包括它们的网络活动、对文件的操作等。</p><h3 id="使用-u-显示指定用户打开了什么"><a href="#使用-u-显示指定用户打开了什么" class="headerlink" title="使用 -u 显示指定用户打开了什么"></a>使用 <code>-u</code> 显示指定用户打开了什么</h3><pre><code class="shell">lsof  -u daniel# 示例结果-- snipped --Dock  155 daniel  txt REG 14,2  2798436  823208  /usr/lib/libicucore.A.dylibDock  155 daniel  txt REG 14,2  1580212  823126  /usr/lib/libobjc.A.dylibDock  155 daniel  txt REG 14,2  2934184  823498  /usr/lib/libstdc++.6.0.4.dylibDock  155 daniel  txt REG 14,2  132008  823505  /usr/lib/libgcc_s.1.dylibDock  155 daniel  txt REG 14,2  212160  823214  /usr/lib/libauto.dylib-- snipped --</code></pre><h3 id="使用-u-user-来显示除指定用户以外的其他所有用户所做的事情"><a href="#使用-u-user-来显示除指定用户以外的其他所有用户所做的事情" class="headerlink" title="使用 $-u^{user}$ 来显示除指定用户以外的其他所有用户所做的事情"></a>使用 $-u^{user}$ 来显示除指定用户以外的其他所有用户所做的事情</h3><pre><code class="shell">lsof  -u ^daniel# 示例结果-- snipped --Dock  155 jim  txt REG 14,2  2798436  823208  /usr/lib/libicucore.A.dylibDock  155 jim  txt REG 14,2  1580212  823126  /usr/lib/libobjc.A.dylibDock  155 jim  txt REG 14,2  2934184  823498  /usr/lib/libstdc++.6.0.4.dylibDock  155 jim  txt REG 14,2  132008  823505  /usr/lib/libgcc_s.1.dylibDock  155 jim  txt REG 14,2  212160  823214  /usr/lib/libauto.dylib-- snipped --</code></pre><h3 id="杀死指定用户所做的一切事情"><a href="#杀死指定用户所做的一切事情" class="headerlink" title="杀死指定用户所做的一切事情"></a>杀死指定用户所做的一切事情</h3><p>可以消灭指定用户运行的所有东西，这真不错。</p><pre><code class="shell">kill  -9  `lsof -t -u daniel`</code></pre><h2 id="命令和进程"><a href="#命令和进程" class="headerlink" title="命令和进程"></a>命令和进程</h2><p>可以查看指定程序或进程由什么启动，这通常会很有用，而你可以使用lsof通过名称或进程ID过滤来完成这个任务。下面列出了一些选项：</p><h3 id="查看-c-查看指定的命令正在使用的文件和网络连接"><a href="#查看-c-查看指定的命令正在使用的文件和网络连接" class="headerlink" title="查看 -c 查看指定的命令正在使用的文件和网络连接"></a>查看 <code>-c</code> 查看指定的命令正在使用的文件和网络连接</h3><pre><code class="shell">lsof  -c syslog-ng# 示例结果COMMAND    PID USER   FD   TYPE     DEVICE    SIZE       NODE NAMEsyslog-ng 7547 root  cwd    DIR 3,3  4096  2  /syslog-ng 7547 root  rtd    DIR 3,3  4096  2  /syslog-ng 7547 root  txt    REG 3,3  113524  1064970  /usr/sbin/syslog-ng-- snipped --</code></pre><h3 id="使用-p-查看指定进程ID（pid）已打开内容-查找指定pid运行路径"><a href="#使用-p-查看指定进程ID（pid）已打开内容-查找指定pid运行路径" class="headerlink" title="使用 -p 查看指定进程ID（pid）已打开内容 [查找指定pid运行路径]"></a>使用 <code>-p</code> 查看指定进程ID（pid）已打开内容 [查找指定pid运行路径]</h3><pre><code class="shell">lsof  -p 10075# 示例结果-- snipped --sshd  10068 root  mem    REG 3,3  34808  850407  /lib/libnss_files-2.4.sosshd  10068 root  mem    REG 3,3  34924  850409  /lib/libnss_nis-2.4.sosshd  10068 root  mem    REG 3,3  26596  850405  /lib/libnss_compat-2.4.sosshd  10068 root  mem    REG 3,3  200152  509940  /usr/lib/libssl.so.0.9.7sshd  10068 root  mem    REG 3,3  46216  510014  /usr/lib/liblber-2.3sshd  10068 root  mem    REG 3,3  59868  850413  /lib/libresolv-2.4.sosshd  10068 root  mem    REG 3,3  1197180  850396  /lib/libc-2.4.sosshd  10068 root  mem    REG 3,3  22168  850398  /lib/libcrypt-2.4.sosshd  10068 root  mem    REG 3,3  72784  850404  /lib/libnsl-2.4.sosshd  10068 root  mem    REG 3,3  70632  850417  /lib/libz.so.1.2.3sshd  10068 root  mem    REG 3,3  9992  850416  /lib/libutil-2.4.so-- snipped --</code></pre><h3 id="t-选项值返回-PID"><a href="#t-选项值返回-PID" class="headerlink" title="-t 选项值返回 PID"></a><code>-t</code> 选项值返回 PID</h3><pre><code class="shell"># 示例lsof  -t -c Mail# 示例结果350</code></pre><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>通过查看指定文件或目录，你可以看到系统上所有正与其交互的资源——包括用户、进程等。</p><h4 id="显示与指定目录交互的所有一切"><a href="#显示与指定目录交互的所有一切" class="headerlink" title="显示与指定目录交互的所有一切"></a>显示与指定目录交互的所有一切</h4><pre><code class="shell"># 示例lsof  /var/log/messages/# 示例结果COMMAND    PID USER   FD   TYPE DEVICE   SIZE   NODE NAMEyslog-ng 7547 root 4w REG 3,3  217309  834024  /var/log/messages</code></pre><h3 id="显示与指定文件交互的所有一切"><a href="#显示与指定文件交互的所有一切" class="headerlink" title="显示与指定文件交互的所有一切"></a>显示与指定文件交互的所有一切</h3><pre><code class="shell">lsof  /home/daniel/firewall_whitelist.txt</code></pre><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>与<a href="http://danielmiessler.com/study/tcpdump/">tcpdump</a>类似，当你开始组合查询时，它就显示了它强大的功能。</p><h3 id="显示-daniel-连接到-1-1-1-1-所做的一切"><a href="#显示-daniel-连接到-1-1-1-1-所做的一切" class="headerlink" title="显示 daniel 连接到 1.1.1.1 所做的一切"></a>显示 <code>daniel</code> 连接到 1.1.1.1 所做的一切</h3><pre><code class="shell"># 示例lsof  -u daniel -i @1.1.1.1# 示例结果bkdr 1893 daniel 3u  IPv6  3456 TCP 10.10.1.10:1234-&gt;1.1.1.1:31337  (ESTABLISHED)</code></pre><h3 id="同时使用-t-和-c-选项以给进程发送-HUP-信号"><a href="#同时使用-t-和-c-选项以给进程发送-HUP-信号" class="headerlink" title="同时使用 -t 和 -c  选项以给进程发送 HUP 信号"></a>同时使用 <code>-t</code> 和 <code>-c</code>  选项以给进程发送 HUP 信号</h3><pre><code class="shell">kill  -HUP `lsof -t -c sshd`</code></pre><h3 id="lsof-L1-显示所有打开的链接数小于"><a href="#lsof-L1-显示所有打开的链接数小于" class="headerlink" title="lsof +L1 显示所有打开的链接数小于"></a><code>lsof +L1</code> 显示所有打开的链接数小于</h3><p>这通常（当不总是）表示某个攻击者正尝试通过删除文件入口来隐藏文件内容。</p><pre><code class="shell"># 示例lsof  +L1# 示例结果(hopefully nothing)</code></pre><h3 id="显示某个端口范围的打开的连接"><a href="#显示某个端口范围的打开的连接" class="headerlink" title="显示某个端口范围的打开的连接"></a>显示某个端口范围的打开的连接</h3><pre><code class="shell">lsof  -i @fw.google.com:2150=2180</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>lsof手册页：<a href="http://www.netadmintools.com/html/lsof.man.html">http://www.netadmintools.com/html/lsof.man.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：修改用户名密码</title>
      <link href="/2021/11/18/Linux%EF%BC%9A%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
      <url>/2021/11/18/Linux%EF%BC%9A%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：修改用户名密码"><a href="#Linux：修改用户名密码" class="headerlink" title="Linux：修改用户名密码"></a>Linux：修改用户名密码</h1><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><pre><code class="shell">passwd 用户名id toptea</code></pre><h2 id="方法二：用-echo-命令修改用户密码"><a href="#方法二：用-echo-命令修改用户密码" class="headerlink" title="方法二：用 echo 命令修改用户密码"></a>方法二：用 echo 命令修改用户密码</h2><p>Linux 通常用passwd修改密码 都要重复确认，现在告诉你一个一句话修改账户密码的命令</p><pre><code class="shell">echo &quot;新密码&quot;|passwd --stdin 用户名</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：sed命令详解</title>
      <link href="/2021/11/18/Linux%EF%BC%9Ased%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/11/18/Linux%EF%BC%9Ased%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：sed命令详解"><a href="#Linux：sed命令详解" class="headerlink" title="Linux：sed命令详解"></a>Linux：sed命令详解</h1><blockquote><p><strong>特点：</strong>替换，修改文件内容，取行</p><p><strong>场景：</strong>如果要进行替换 / 修改文件内容，取出某个范围的内容（比如日志中从早上8点到下午12点）</p></blockquote><h2 id="特点及格式"><a href="#特点及格式" class="headerlink" title="特点及格式"></a>特点及格式</h2><ul><li><p>sed（stream editor：流编辑器），sed 把处理的内容（文件）当做是水，源源不断的进行处理，直到文件末尾</p></li><li><p>sed 格式：</p><pre><code class="shell"># 命令    选项    （s）sed命令功能（g）修饰符    参数（文件）  sed     -r        &#39;s#oldboy#oldgirl#g&#39;      oldboy.txt</code></pre><table><thead><tr><th>命令</th><th>选项</th><th>（s）sed命令功能（g）修饰符</th><th>参数（文件）</th></tr></thead><tbody><tr><td>sed</td><td>-r</td><td>‘s#oldboy#oldgirl#g’</td><td>oldboy.txt</td></tr></tbody></table></li><li><p>sed 命令核心功能：增删改查</p><pre><code class="shell">s    # 替换 substitute sub    [核心]p    # 显示 print    [核心]d    # 删除 delete，以行为单位    [核心]cai    # 增加 c/a/i</code></pre></li></ul><h2 id="sed-命令执行过程"><a href="#sed-命令执行过程" class="headerlink" title="sed 命令执行过程"></a>sed 命令执行过程</h2><ul><li><p>四字描述：“找谁干啥”</p></li><li><p>找谁：你要哪一行</p></li><li><p>干啥：增删改查</p>  <img src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/sed%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B1.png" alt="sed命令执行过程"  /></li></ul><h2 id="sed-核心应用"><a href="#sed-核心应用" class="headerlink" title="sed 核心应用"></a>sed 核心应用</h2><h3 id="sed-查找-过滤-p（一般遇到-p-会加-n）"><a href="#sed-查找-过滤-p（一般遇到-p-会加-n）" class="headerlink" title="sed - 查找 / 过滤 p（一般遇到 p 会加 -n）"></a>sed - 查找 / 过滤 p（一般遇到 p 会加 -n）</h3><table><thead><tr><th>查找格式</th><th>功能</th></tr></thead><tbody><tr><td>‘1p’  ‘2p’</td><td>指定行号进行查找</td></tr><tr><td>‘1,5p’</td><td>指定行号范围进行查找（最后一行为 $）</td></tr><tr><td>‘//p’ （//中写需要找的单词）</td><td>类似于 grep 过滤，// 里面可以写正则</td></tr><tr><td>‘//,//p’</td><td>表示范围的过滤，常用于找日志，如 ‘/10:00/,/11:00/p’；如果结尾不存在，则直接到文件的最后一行</td></tr></tbody></table><h3 id="sed-整行-删除-d-（delete）"><a href="#sed-整行-删除-d-（delete）" class="headerlink" title="sed - [整行]删除 d    （delete）"></a>sed - [整行]删除 d    （delete）</h3><table><thead><tr><th>查找格式</th><th>功能</th></tr></thead><tbody><tr><td>‘1d’  ‘2d’</td><td>指定行号进行查找</td></tr><tr><td>‘1,5d’</td><td>指定行号范围进行查找（最后一行为 $）</td></tr><tr><td>‘//d’ （//中写需要找的单词）</td><td>类似于 grep 过滤，// 里面可以写正则</td></tr><tr><td>‘//,//d’</td><td>表示范围的过滤，常用于找日志，如 ‘/10:00/,/11:00/p’；如果结尾不存在，则直接到文件的最后一行</td></tr></tbody></table><p>eg：删除文件中的空行和包含 # 号的行</p><pre><code class="shell"># 方法一：egrepegrep -v &#39;^$|#&#39; test.log# 方法二：sedsed -r &#39;/^$|#/d&#39; test.log# 方法三：! 妙用 （取反，排除）sed -nr &#39;/^$|#/!p&#39; test.log</code></pre><h3 id="sed-增加-cai"><a href="#sed-增加-cai" class="headerlink" title="sed - 增加 cai"></a>sed - 增加 cai</h3><table><thead><tr><th>命令</th><th></th></tr></thead><tbody><tr><td>c</td><td>replace 替代，替代这行内容</td></tr><tr><td><strong>a</strong></td><td>append 追加，向指定行或每一行追加的内容（行后面） &gt;&gt;</td></tr><tr><td>i</td><td>insert 插入，向指定的行或每一行插入内容（行前面）</td></tr></tbody></table><p>eg：</p><pre><code class="shell">sed &#39;3a 996,lindao,CTO&#39; test.txt</code></pre><pre><code class="shell">:&lt;&lt;!    向文件中追加多行内容    向 config 里面追加    useDNS    no    GSSAPIAUTCATION    no    PermitROOTLogin    no!# 方法一：推荐cat &gt;&gt;config&lt;&lt;&#39;EOF&#39;useDNS    noGSSAPIAUTCATION    noPermitROOTLogin    noEOF# 方法二：sedsed &#39;$a useDNS    no\nGSSAPIAUTCATION    no\nPermitROOTLogin    no&#39; config</code></pre><h3 id="sed-替换-s"><a href="#sed-替换-s" class="headerlink" title="sed - 替换 s"></a>sed - 替换 s</h3><ul><li>s（替换，sub，substitute）</li><li>g（全局替换，global；sed 替换每行所有匹配的内容，sed 默认只替换每一行匹配的内容）</li></ul><table><thead><tr><th>替换格式(第一个 # 后跟正则表达式)</th></tr></thead><tbody><tr><td>s###g</td></tr><tr><td>s///g</td></tr><tr><td>s@@@g</td></tr></tbody></table><h3 id="sed-后向引用-方向引用"><a href="#sed-后向引用-方向引用" class="headerlink" title="sed - 后向引用 / 方向引用"></a>sed - 后向引用 / 方向引用</h3><ul><li>口诀：先保护，再引用（使用在后两个 # 里使用）</li></ul><p>eg：想将 123456 改为 &lt;123456&gt;</p><pre><code class="shell">echo 123456 | sed -r &#39;s#(.*)#&lt;\1&gt;#g&#39;    # 其中 \1 表示第一组</code></pre><p>eg：oldboy_lidao 两个单词颠倒</p><pre><code class="shell">echo oldboy_lidao | sed -r &#39;s#(^.*)_(.*$)#\2\1#g&#39;</code></pre><p>eg：找到指定网卡的 ip</p><pre><code class="shell">ip a s eth0 | sed -n &#39;3p&#39; | sed -r &#39;s#(^.*t )(.*)(/.*$)#\2#g&#39;或ip a s eth0 | sed -n &#39;3p&#39; | sed -r &#39;s#^.*t (.*)/.*$#\1#g&#39;## 精简ip a s eth0 | sed -rn &#39;3s#^.*t (.*)/.*$#\1#&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：怎么查看磁盘是否满了</title>
      <link href="/2021/11/18/Linux%EF%BC%9A%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E6%98%AF%E5%90%A6%E6%BB%A1%E4%BA%86/"/>
      <url>/2021/11/18/Linux%EF%BC%9A%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E6%98%AF%E5%90%A6%E6%BB%A1%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：怎么查看磁盘是否满了"><a href="#Linux：怎么查看磁盘是否满了" class="headerlink" title="Linux：怎么查看磁盘是否满了"></a>Linux：怎么查看磁盘是否满了</h1><pre><code class="shell">df -hl# 显示格式为：# 文件系统 容量 已用 可用 已用% 挂载点</code></pre><pre><code class="shell"># 查看磁盘剩余空间df -hl # 查看每个根路径的分区大小df -h # 返回该目录的大小du -sh [目录名] # 返回该文件夹总m数du -sm [文件夹] </code></pre><pre><code class="shell"># 查看硬盘的分区sudo fdisk -l查看ide硬盘信息 #sudo hdparm -i /dev/hda查看stat硬盘信息 #sudo hdparm -i /dev/sda 或 #sudo apt-get install blktool #sudo blktool /dev/sda id# 查看硬盘剩余空间df -h# 查看目录占用空间 du -hs 目录名# 优盘没法卸载sync fuser -km /media/usbdisk</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：改变用户所属用户组</title>
      <link href="/2021/11/18/Linux%EF%BC%9A%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E6%89%80%E5%B1%9E%E7%94%A8%E6%88%B7%E7%BB%84/"/>
      <url>/2021/11/18/Linux%EF%BC%9A%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E6%89%80%E5%B1%9E%E7%94%A8%E6%88%B7%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：改变用户所属用户组"><a href="#Linux：改变用户所属用户组" class="headerlink" title="Linux：改变用户所属用户组"></a>Linux：改变用户所属用户组</h1><p>基本语法：</p><pre><code class="shell"># 修改文件所属组群chgrp  用户名    文件名  -R#修改文件拥有者chown 用户名   文件名  -Rchown 用户名:用户名   文件名  -R</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：查看网</title>
      <link href="/2021/11/18/Linux%EF%BC%9A%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%8D%A1/"/>
      <url>/2021/11/18/Linux%EF%BC%9A%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：查看网卡"><a href="#Linux：查看网卡" class="headerlink" title="Linux：查看网卡"></a>Linux：查看网卡</h1><pre><code class="shell"># 查看所有网卡ip a# 指定显示模块网卡的信息ip addr show eth0# 简写ip a s eth0    </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：查看进程使用内存</title>
      <link href="/2021/11/18/Linux%EF%BC%9A%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/"/>
      <url>/2021/11/18/Linux%EF%BC%9A%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：查看进程使用内存"><a href="#Linux：查看进程使用内存" class="headerlink" title="Linux：查看进程使用内存"></a>Linux：查看进程使用内存</h1><pre><code class="shell"># 方法一：使用 smaps，单位 KBcat /proc/73375/smaps | grep &#39;^Rss:&#39; | awk &#39;&#123;sum +=$2&#125; END&#123;print sum&#125;&#39;# 方法二：单位 G，输出时会显示单位top -bn 1 -p 73375|sed /^[[:space:]]*$/d|tail -1|awk -F &#39; &#39; &#39;&#123;print $6&#125;&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：目录结构</title>
      <link href="/2021/11/18/Linux%EF%BC%9A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2021/11/18/Linux%EF%BC%9A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：目录结构"><a href="#Linux：目录结构" class="headerlink" title="Linux：目录结构"></a>Linux：目录结构</h1><h2 id="具体目录结构（不用背，知道即可）"><a href="#具体目录结构（不用背，知道即可）" class="headerlink" title="具体目录结构（不用背，知道即可）"></a>具体目录结构（<font color='red'>不用背，知道即可</font>）</h2><p><img src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/linux%E7%9B%AE%E5%BD%95.jpg" alt="linux目录"></p><p>（1）/bin    [常用]    （/usr/bin、/usr/local/bin）</p><p>​            是 Binary 的缩写、这个目录存放着最经常使用的命令。</p><p>（2）/sbin    （usr/sbin、/usr/local/sbin）</p><p>​            s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。</p><p>（3）/home    [常用]</p><p>​            存放普通目录的主目录，在 Linux 中每个用户都有一个自己的目录，一般该目录是以用户的账号命名。</p><p>（4）/root    [常用]</p><p>​            该目录为系统管理员，也称为超级权限者的用户主目录。</p><p>（5）/lib    </p><p>​            系统开机所需要最基本的动态链接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p><p>（6）/lost+found    </p><p>​            这个没有了一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p><p>（7）/etc    [常用]</p><p>​            所有的系统管理所需要的配置文件和子目录，比如安装 MySQL 数据库的 my.conf。<br>（8）/usr    [常用]</p><p>​            这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 Windows 下的 program files 目录。</p><p>（9）/boot    [常用]</p><p>​            存放的是启动 Linux 时使用的一些核心文件，包括一些链接文件以及镜像文件。</p><p>（10）/proc    [不能动]</p><p>​            这个目录是一个虚拟目录，它是系统内存的映射，访问这个目录来获取系统信息。</p><p>（11）/srv    [不能动]</p><p>​            service 缩写，该目录存放一些服务启动之后需要提取的数据。</p><p>（12）/sys    [不能动]</p><p>​            这是 linux2.6 内核的一个很大变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs =》【别动】</p><p>（13）/tmp</p><p>​            这个目录是用来存放一些临时文件的。</p><p>（14）/dev</p><p>​            类似于 Windows 的设备管理器，把所有的硬件用文件的形式存储。</p><p>（15）/media    [常用]</p><p>​            Linux 系统会自动识别一些设备，例如 U盘，光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p><p>（16）/mnt    [常用]</p><p>​            系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在 /mnt/ 上，然后进入该目录就可以查看里面的内容了。</p><p>（17）/opt    </p><p>​            这是给主机额外安装软件所存放的目录。如安装 Oracle 数据库就可以放到该目录下，默认为空，</p><p>（18）/usr/local    [常用]</p><p>​            这是另一个给主机额外安装软禁所安装的目录。一般是通过编译源码方式安装的程序。</p><p>（19）/var    [常用]</p><p>​            这个目录中存放着在不断扩充的东西，习惯将被修改的目录放在这个目录下。包括各种日志文件。</p><p>（20）/selinux    [security-enhanced linux]</p><p>​            SELinux 是一种安全子系统，它能控制程序只访问特定文件，有三种工作模式，可以自行设置。</p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tar 命令</title>
      <link href="/2021/11/18/Linux%EF%BC%9A%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/18/Linux%EF%BC%9A%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h1><pre><code class="shell">tar-c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。-z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 下面的参数 -f 是必须的:-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。-C&lt;目的目录&gt; 或 --directory=&lt;目的目录&gt; 切换到指定的目录。</code></pre><ul><li>gzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。</li><li>与 gzip 相对的解压程序是 gunzip。</li><li>tar 中使用 -z 这个参数来调用gzip。</li></ul><p><strong>下面来举例说明一下：</strong></p><pre><code class="shell"># tar -czf all.tar.gz *.jpg这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，包名为 all.tar.gz。# tar -xzf all.tar.gz这条命令是将上面产生的包解开。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux：重定向符号</title>
      <link href="/2021/11/18/Linux%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6%E5%8F%B7/"/>
      <url>/2021/11/18/Linux%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux：重定向符号"><a href="#Linux：重定向符号" class="headerlink" title="Linux：重定向符号"></a>Linux：重定向符号</h1><pre><code class="shell">&lt; :输入重定向&gt; :输出重定向&gt;&gt; :输出重定向,追加,不覆盖之前内容&lt;&lt; :标准输入来自命令行的一对分隔号的中间内容</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux df 显示目前文件系统磁盘使用情况</title>
      <link href="/2021/11/18/Linux-df-%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%89%8D%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/"/>
      <url>/2021/11/18/Linux-df-%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%89%8D%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-df-显示目前文件系统磁盘使用情况"><a href="#Linux-df-显示目前文件系统磁盘使用情况" class="headerlink" title="Linux df 显示目前文件系统磁盘使用情况"></a>Linux df 显示目前文件系统磁盘使用情况</h1><pre><code class="shell">df [选项]... [FILE]...</code></pre><ul><li>文件-a, –all 包含所有的具有 0 Blocks 的文件系统</li><li>文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks</li><li>文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)</li><li>文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024</li><li>文件-i, –inodes 列出 inode 资讯，不列出已使用 block</li><li>文件-k, –kilobytes 就像是 –block-size=1024</li><li>文件-l, –local 限制列出的文件结构</li><li>文件-m, –megabytes 就像 –block-size=1048576</li><li>文件–no-sync 取得资讯前不 sync (预设值)</li><li>文件-P, –portability 使用 POSIX 输出格式</li><li>文件–sync 在取得资讯前 sync</li><li>文件-t, –type=TYPE 限制列出文件系统的 TYPE</li><li>文件-T, –print-type 显示文件系统的形式</li><li>文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE</li><li>文件-v (忽略)</li><li>文件–help 显示这个帮手并且离开</li><li>文件–version 输出版本资讯并且离开</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 多行注释</title>
      <link href="/2021/11/18/Shell%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/"/>
      <url>/2021/11/18/Shell%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-多行注释"><a href="#Shell-多行注释" class="headerlink" title="Shell 多行注释"></a>Shell 多行注释</h1><ul><li><p><strong>方法一</strong></p><pre><code class="shell">:&lt;&lt;!#被注释的内容   !</code></pre></li><li><p><strong>方法二</strong></p><pre><code class="shell">：&#39;#被注释的内容&#39;</code></pre></li><li><p><strong>方法三</strong></p><pre><code class="shell">if false;then#被注释的内容fi</code></pre></li><li><p><strong>方法四</strong></p><pre><code class="shell">:&lt;&lt;任意字符或者数字#被煮熟的内容任意字符或者数字</code></pre></li><li><p><strong>方法五</strong></p><pre><code class="shell">((0)) &amp;&amp; &#123;#被注释的内容&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 字符串比较</title>
      <link href="/2021/11/18/Shell%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"/>
      <url>/2021/11/18/Shell%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-字符串比较"><a href="#Shell-字符串比较" class="headerlink" title="Shell 字符串比较"></a>Shell 字符串比较</h1><p><strong>字符串相等</strong></p><pre><code class="shell">[[ $str1 == $str2 ]]</code></pre><p><strong>字符串不相等</strong></p><pre><code class="shell">[[ $str1 != $str2 ]]</code></pre><p><strong>字符串大小比较</strong></p><pre><code class="shell">[[ $str1 &gt; $str2 ]]</code></pre><p><strong>字符串等于空</strong></p><pre><code class="shell">[[  -z $str2 ]]</code></pre><p><strong>字符串不等于空</strong></p><pre><code class="shell">[[  -n $str2 ]]</code></pre><p><strong>用test代替[]</strong></p><pre><code class="shell">if test $str1 == $str2</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell批量查看主机是否是虚拟机</title>
      <link href="/2021/11/18/Shell%E6%89%B9%E9%87%8F%E6%9F%A5%E7%9C%8B%E4%B8%BB%E6%9C%BA%E6%98%AF%E5%90%A6%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2021/11/18/Shell%E6%89%B9%E9%87%8F%E6%9F%A5%E7%9C%8B%E4%B8%BB%E6%9C%BA%E6%98%AF%E5%90%A6%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell批量查看主机是否是虚拟机"><a href="#Shell批量查看主机是否是虚拟机" class="headerlink" title="Shell批量查看主机是否是虚拟机"></a>Shell批量查看主机是否是虚拟机</h1><pre><code class="shell">#! /bin/bashecho &quot;&quot; &gt;vmware.lstecho &quot;&quot; &gt;other.lstecho &quot;&quot; &gt;networkerr.lststr=&quot;VMware Virtual Platform&quot;for i in `cat ip.lst`do        # ifvm=`dmidecode -s system-product-name`        ifvm=`ssh root@$i &quot;dmidecode -s system-product-name&quot;`        echo $ifvm        if [ &quot;$ifvm&quot; = &quot;$str&quot; ]; then                echo  $i &gt;&gt;vmware.lst        else                echo $i &gt;&gt;other.lst        fidone</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本中`$0`、`$?`、`$!`、`$$`、`$*`、`$#`、`$@`等的意义【预定义变量】</title>
      <link href="/2021/11/18/Shell%E8%84%9A%E6%9C%AC%E4%B8%AD$0%E3%80%81$%E3%80%81$!%E3%80%81$$%E3%80%81$%E3%80%81$#%E3%80%81$@%E7%AD%89%E7%9A%84%E6%84%8F%E4%B9%89/"/>
      <url>/2021/11/18/Shell%E8%84%9A%E6%9C%AC%E4%B8%AD$0%E3%80%81$%E3%80%81$!%E3%80%81$$%E3%80%81$%E3%80%81$#%E3%80%81$@%E7%AD%89%E7%9A%84%E6%84%8F%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell脚本中-0、-、-、-、-、-、-等的意义【预定义变量】"><a href="#Shell脚本中-0、-、-、-、-、-、-等的意义【预定义变量】" class="headerlink" title="Shell脚本中$0、$?、$!、$$、$*、$#、$@等的意义【预定义变量】"></a>Shell脚本中<code>$0</code>、<code>$?</code>、<code>$!</code>、<code>$$</code>、<code>$*</code>、<code>$#</code>、<code>$@</code>等的意义【预定义变量】</h1><h2 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h2><pre><code class="shell"># $$：(登录) Shell 本身的 PID（ProcessID）# $!：Shell 最后运行的后台 Process 的 PID# $?：最后运行的命令的结束代码（成功：0；失败：1）# $-：使用 Set 命令设定的 Flag 一览# $*：所有参数列表。如 &quot;$*&quot; 用&quot;&quot;括起来的情况、以 &quot;$1 $2 ... $n&quot; 的形式输出所有参数# $@：所有参数列表。如 &quot;$@&quot; 用&quot;&quot;括起来的情况、以 &quot;$1&quot;&quot;$2&quot; ... &quot;$n&quot; 的形式输出所有参数# $#：添加到 Shell 的参数个数# $0：Shell 本身的文件名# $1～$n：添加到 Shell 的各参数值。$1 是第 1 参数、$2 是第 2 参数...。</code></pre><pre><code class="shell"># 判断是否有 agent 进程        varwc=`ps -ef |grep agent70 |grep -v grep |wc -l`        if [echo $varwc -ne 0]; then            echo &quot;error: already have agent&quot; &gt;&gt; $logfile            echo &quot;shell exit!!!&quot;        fi</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本批量杀死某目录下所有进程并重启</title>
      <link href="/2021/11/18/Shell%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E6%9D%80%E6%AD%BB%E6%9F%90%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E8%BF%9B%E7%A8%8B%E5%B9%B6%E9%87%8D%E5%90%AF/"/>
      <url>/2021/11/18/Shell%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E6%9D%80%E6%AD%BB%E6%9F%90%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E8%BF%9B%E7%A8%8B%E5%B9%B6%E9%87%8D%E5%90%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell脚本批量杀死某目录下所有进程并重启"><a href="#Shell脚本批量杀死某目录下所有进程并重启" class="headerlink" title="Shell脚本批量杀死某目录下所有进程并重启"></a>Shell脚本批量杀死某目录下所有进程并重启</h1><p><strong>agent_file_fail.sh</strong></p><pre><code class="shell">#!/bin/bashpid=$(lsof -t /home/toptea/ccp/agent70.disabled)if [[ $pid -ne 0 ]]; then        lsof -p $pid        echo &quot;=====================&quot;        echo &quot;this is now pid: $pid&quot;        echo &quot;get agent pid:$pid success&quot;fikill -9 $pidps -ef|grep agent70rm -rf /home/toptea/ccp/agent70.disabledcd /home/toptea/agent70/binsh start.sh</code></pre><p><strong>开始批量操作：start_agent_file_fail.sh</strong></p><pre><code class="shell">#!/bin/bash# 需要批量操作的ipstring=&quot;10.78.182.54;10.78.133.75&quot;array=($&#123;string//;/ &#125;)for var in $&#123;array[@]&#125;doscp agent_file_fail.sh root@$var:/home/toptea/ssh root@$var &quot;sh /home/toptea/agent_file_fail.sh&quot;done</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本批量测试SSH是否可以免密登录</title>
      <link href="/2021/11/18/Shell%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95SSH%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/2021/11/18/Shell%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95SSH%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell脚本批量测试SSH是否可以免密登录"><a href="#Shell脚本批量测试SSH是否可以免密登录" class="headerlink" title="Shell脚本批量测试SSH是否可以免密登录"></a>Shell脚本批量测试SSH是否可以免密登录</h1><blockquote><p><strong>前提：要保证所有本地到目标主机的22端口已打开</strong></p></blockquote><pre><code class="shell">#!/bin/bash# 需要测试的 ip 地址string=&quot;200.200.200.200;10.78.186.52&quot;mkdir logstouch logs/sucess.logtouch logs/fail.logarray=($&#123;string//;/ &#125;)for var in $&#123;array[@]&#125;dotimeout 5 ssh root@$var echo &quot;$var SSH has passwordless access!&quot;  &gt;&gt; logs/fail.logif [[ $? -ne 0 ]]; then    # 无 ssh 免密    echo &quot;$var SSH has no passwordless access!&quot; &gt;&gt; logs/sucess.logfidone</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 远程登录后执行命令</title>
      <link href="/2021/11/18/Shell%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%90%8E%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/18/Shell%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%90%8E%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-远程登录后执行命令"><a href="#Shell-远程登录后执行命令" class="headerlink" title="Shell 远程登录后执行命令"></a>Shell 远程登录后执行命令</h1><h2 id="Shell-远程主机执行单条命令"><a href="#Shell-远程主机执行单条命令" class="headerlink" title="Shell 远程主机执行单条命令"></a>Shell 远程主机执行单条命令</h2><pre><code class="shell">ssh USER@HOST &#39;COMMAN&#39;</code></pre><h2 id="Shell-远程主机执行多条命令"><a href="#Shell-远程主机执行多条命令" class="headerlink" title="Shell 远程主机执行多条命令"></a>Shell 远程主机执行多条命令</h2><pre><code class="shell"># 方法一ssh USER@HOST &#39;COMMAN1;COMMAN2;COMMAN3&#39;# 方法二ssh USER@HOST &#39;COMMAN1|COMMAN2|COMMAN3&#39;# 方法三ssh USER@HOST &lt;&lt; EOFCOMMAN1COMMAN2COMMAN3EOF</code></pre><h2 id="Shell-登录远程主机执行指定脚本文件"><a href="#Shell-登录远程主机执行指定脚本文件" class="headerlink" title="Shell 登录远程主机执行指定脚本文件"></a>Shell 登录远程主机执行指定脚本文件</h2><pre><code class="shell">ssh USER@HOST &#39;bash -s&#39; &lt; SCRIPT# 例子ssh root@192.168.1.1 &#39;bash -s&#39; &lt; script.sh</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make 2&gt;&amp;1 | tee log.txt 命令解析</title>
      <link href="/2021/11/18/make%202&amp;1%20%20tee%20log.txt%20%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/11/18/make%202&amp;1%20%20tee%20log.txt%20%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="make-2-gt-amp-1-tee-log-txt-命令解析"><a href="#make-2-gt-amp-1-tee-log-txt-命令解析" class="headerlink" title="make 2&gt;&amp;1 | tee log.txt 命令解析"></a>make 2&gt;&amp;1 | tee log.txt 命令解析</h1><p>1、<code>make</code>是什么？</p><p>make是linux下一个非常强大的命令，简单点就是你要编译你的源代码就得靠他了。</p><p>2、<code>2&gt;&amp;1</code>是什么意思？</p><p><strong>0 stdin，1 stdout，2 stderr</strong></p><p>2&gt;&amp;1应该分成两个部分来看，一个是2&gt;以及另一个是&amp;1；</p><p>其中<code>2&gt;</code>就是将标准出错重定向到某个特定的地方；<code>&amp;1</code>是指无论标准输出在哪里。</p><p><strong>所以<code>2&gt;&amp;1</code>的意思就是说无论标准出错在哪里，都将标准出错重定向到标准输出中。</strong></p><p>有时候希望将错误的信息重新定向到输出，就是将2的结果重定向至1中就有了”2&gt;1”这样的思路，如果按照上面的写法，系统会默认将错误的信息（STDERR）2重定向到一个名字为1的文件中，而非所想的（STDOUT）中。因此需要加&amp;进行区分。就有了 2&gt;&amp;1 这样的用法</p><p>3、<code>|</code>管道</p><p>管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。</p><p>通常使用管道的好处是一方面形式上简单，另一方面其执行效率要远高于使用临时文件。</p><p>这里使用管道的目的是将make程序的输出重定向到下一个程序，其最终目的是用来将输出log存入文件中。</p><p>4、<code>tee</code>是用来干什么的？</p><p><code>tee</code>从标准输入中读取，并将读入的内容写到标准输出及文件中。</p><p>所以这里<code>tee</code>命令的作用是将数据读入并写到标准输出以及log.txt中。</p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nc命令批量测试端口脚本</title>
      <link href="/2021/11/18/nc%E5%91%BD%E4%BB%A4%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/11/18/nc%E5%91%BD%E4%BB%A4%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="nc命令批量测试端口脚本"><a href="#nc命令批量测试端口脚本" class="headerlink" title="nc命令批量测试端口脚本"></a>nc命令批量测试端口脚本</h1><p><strong>nc命令测试端口：</strong></p><pre><code class="shell">cat /dev/null | nc &lt;hostname&gt; &lt;port&gt;</code></pre><p><strong>批量测试脚本：</strong></p><pre><code class="shell">#!/bin/bashstring=&quot;10.72.228.21;10.72.236.24;10.70.186.21;10.76.232.20;10.78.198.230&quot;array=($&#123;string//;/ &#125;)for var in $&#123;array[@]&#125;doecho &quot;=============test ip: $var link start===================&quot;touch &quot;logs/$var.log&quot;cat /dev/null| nc -v -w 5  -t $var $1if [ $? -eq 0 ];then    echo &quot;$var:$1    connect success&quot; &gt;&gt;&quot;logs/$var.log&quot;else    echo &quot;$var:$1    connect failed&quot; &gt;&gt;&quot;logs/$var.log&quot;fiecho &quot;=============test ip: $var link end===================&quot;done</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis安装zmalloc.h: 致命错误：jemalloc/jemalloc.h：没有那个文件或目录</title>
      <link href="/2021/11/18/redis%E5%AE%89%E8%A3%85zmalloc.h5031%20%E8%87%B4%E5%91%BD%E9%94%99%E8%AF%AF%EF%BC%9Ajemallocjemalloc.h%EF%BC%9A%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/11/18/redis%E5%AE%89%E8%A3%85zmalloc.h5031%20%E8%87%B4%E5%91%BD%E9%94%99%E8%AF%AF%EF%BC%9Ajemallocjemalloc.h%EF%BC%9A%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="redis安装zmalloc-h-50-31-致命错误：jemalloc-jemalloc-h：没有那个文件或目录"><a href="#redis安装zmalloc-h-50-31-致命错误：jemalloc-jemalloc-h：没有那个文件或目录" class="headerlink" title="redis安装zmalloc.h:50:31: 致命错误：jemalloc/jemalloc.h：没有那个文件或目录"></a>redis安装zmalloc.h:50:31: 致命错误：jemalloc/jemalloc.h：没有那个文件或目录</h1><p><strong>问题：</strong>zmalloc.h:50:31: 致命错误：jemalloc/jemalloc.h：没有那个文件或目录</p><p><img src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210714231342266.png" alt="image-20210714231342266"></p><p><strong>解决方案：</strong></p><p>执行命令：make MALLOC=libc</p><pre><code class="shell">make MALLOC=libc</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reids </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scp传输文件命令</title>
      <link href="/2021/11/18/scp%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/18/scp%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="scp-传输文件命令"><a href="#scp-传输文件命令" class="headerlink" title="scp 传输文件命令"></a>scp 传输文件命令</h1><pre><code class="shell">scp 文件名 用户名@ip:目标地址</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scp报错：not a regular file</title>
      <link href="/2021/11/18/scp%E6%8A%A5%E9%94%99%EF%BC%9Anot%20a%20regular%20file/"/>
      <url>/2021/11/18/scp%E6%8A%A5%E9%94%99%EF%BC%9Anot%20a%20regular%20file/</url>
      
        <content type="html"><![CDATA[<h1 id="scp报错：not-a-regular-file"><a href="#scp报错：not-a-regular-file" class="headerlink" title="scp报错：not a regular file"></a>scp报错：not a regular file</h1><pre><code class="shell"># linux 本地文件上传到服务器scp 文件 用户@IP:路径# 从服务器下载文件scp 用户@IP:服务器文件路径 本地路径</code></pre><p>当发生报错：<code>not a regular file</code></p><p>原因是：这样是相当于下载文件夹，而非文件。上传文件夹同样用 <code>-r</code></p><p>解决方法：加参数 <code>-r</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell基础 - dirname $0 用法</title>
      <link href="/2021/11/18/shell%E5%9F%BA%E7%A1%80%20-%20$(cd%20%60dirname%20$0%60;pwd)/"/>
      <url>/2021/11/18/shell%E5%9F%BA%E7%A1%80%20-%20$(cd%20%60dirname%20$0%60;pwd)/</url>
      
        <content type="html"><![CDATA[<h1 id="shell基础-dirname-0-用法"><a href="#shell基础-dirname-0-用法" class="headerlink" title="shell基础 - dirname $0 用法"></a>shell基础 - dirname $0 用法</h1><pre><code class="shell">dirname $0 :取得当前执行脚本文件的运行目录cd `dirname $0` :进入这个目录</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 脚本生产随机数</title>
      <link href="/2021/11/18/shell%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2021/11/18/shell%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-脚本生产随机数"><a href="#Shell-脚本生产随机数" class="headerlink" title="Shell 脚本生产随机数"></a>Shell 脚本生产随机数</h1><pre><code class="shell">#!/bin/bashecho $RANDOM &gt;&gt; /tmp/test.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh 远程连接出现 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</title>
      <link href="/2021/11/18/ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%87%BA%E7%8E%B0WARNING%20REMOTE%20HOST%20IDENTIFICATION%20HAS%20CHANGED!/"/>
      <url>/2021/11/18/ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%87%BA%E7%8E%B0WARNING%20REMOTE%20HOST%20IDENTIFICATION%20HAS%20CHANGED!/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh远程连接出现WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED"><a href="#ssh远程连接出现WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED" class="headerlink" title="ssh远程连接出现WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!"></a>ssh远程连接出现WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</h1><blockquote><p>连接Linux服务器时出现<code>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED</code>，会导致这一警告信息是因为，第一次进行SSH连接时，会生成一个认证存储在客户端中的<code>known_hosts</code>，但如果服务器重新装过或认证信息发生变化。这时候服务器和客户端的信息不匹配时，就会出现错误。解决办法就是将<code>known_hosts</code>文件中那个无效的记录删除即可。</p></blockquote><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p><img src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/1210730-20200905084220881-492969779.png" alt="img"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><pre><code class="shell">ssh-keygen -R 目标主机</code></pre><pre><code class="shell">[root@cdsywtb-web-r83 ~]# ssh-keygen -R 172.24.xxx.xx# Host 172.24.xxx.xx found: line 14/root/.ssh/known_hosts updated.</code></pre><p><strong>验证</strong></p><p><img src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/1210730-20200905084149903-1469239640.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vi、vim学习</title>
      <link href="/2021/11/18/vi%E3%80%81vim%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/18/vi%E3%80%81vim%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="vi、vim学习"><a href="#vi、vim学习" class="headerlink" title="vi、vim学习"></a>vi、vim学习</h1><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="一般模式下："><a href="#一般模式下：" class="headerlink" title="一般模式下："></a>一般模式下：</h3><ol><li>拷贝当前行：<code>yy</code>，拷贝当前行下的5行：<code>5yy</code>，粘贴：<code>p</code></li><li>删除当前行：<code>dd</code>，删除当前行下的5行：<code>5dd</code></li><li>定位到文档的最末行：<code>G</code>、定位首行：<code>gg</code></li><li>撤销上一步操作：<code>u </code></li><li>恢复上一步被撤销的操作：<code>ctrl + r</code></li><li>快速定位到第 n 行：<code>n+shift+g</code></li></ol><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><ol><li>查找单词：命令行下 <code>/</code> 关键字，回车 查找，输入 <code>n</code> 就是查找下一个</li><li>设置文件的行号：命令行下 <code>:set nu</code> 和 <code>:set nonu</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以非 root 用户编辑 crontab 提示 You are not allowed to use this program(crontab)</title>
      <link href="/2021/11/18/%E4%BB%A5%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E7%BC%96%E8%BE%91crontab%E6%8F%90%E7%A4%BA%20You%20are%20not%20allowed%20to%20use%20this%20program(crontab)/"/>
      <url>/2021/11/18/%E4%BB%A5%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E7%BC%96%E8%BE%91crontab%E6%8F%90%E7%A4%BA%20You%20are%20not%20allowed%20to%20use%20this%20program(crontab)/</url>
      
        <content type="html"><![CDATA[<h1 id="以非-root-用户编辑-crontab-提示-You-are-not-allowed-to-use-this-program-crontab"><a href="#以非-root-用户编辑-crontab-提示-You-are-not-allowed-to-use-this-program-crontab" class="headerlink" title="以非 root 用户编辑 crontab 提示 You are not allowed to use this program(crontab)"></a>以非 root 用户编辑 crontab 提示 You are not allowed to use this program(crontab)</h1><p>问题原因：<code>/etc/cron.allow</code> 中没有添加对应的用户</p><p>解决办法：在 <code>/etc/cron.allow</code> 中添加对应的用户</p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改 ssh 登录后默认显示的路径</title>
      <link href="/2021/11/18/%E4%BF%AE%E6%94%B9ssh%E7%99%BB%E5%BD%95%E5%90%8E%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/11/18/%E4%BF%AE%E6%94%B9ssh%E7%99%BB%E5%BD%95%E5%90%8E%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="修改-ssh-登录后默认显示的路径"><a href="#修改-ssh-登录后默认显示的路径" class="headerlink" title="修改 ssh 登录后默认显示的路径"></a>修改 ssh 登录后默认显示的路径</h1><p>1、登录到 ssh 服务器</p><p>2、<code>vim ~/.bashrc </code></p><p>3、添加一行：例如：<code>cd /home/prod</code></p><img src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210902113950402.png" alt="image-20210902113950402" style="zoom:50%;" /><p>4、再次 ssh 服务器，默认目录显示为 <code>/home/prod</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu 20.04上安装GCC（build-essential）</title>
      <link href="/2021/11/18/%E5%9C%A8Ubuntu%2020.04%E4%B8%8A%E5%AE%89%E8%A3%85GCC%EF%BC%88build-essential%EF%BC%89/"/>
      <url>/2021/11/18/%E5%9C%A8Ubuntu%2020.04%E4%B8%8A%E5%AE%89%E8%A3%85GCC%EF%BC%88build-essential%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="在Ubuntu-20-04上安装GCC（build-essential）"><a href="#在Ubuntu-20-04上安装GCC（build-essential）" class="headerlink" title="在Ubuntu 20.04上安装GCC（build-essential）"></a>在Ubuntu 20.04上安装GCC（build-essential）</h1><blockquote><p><strong>简介：</strong> GNU 编译器集合是一系列用于语言开发的编译器和库的集合，包括: C, C++, Objective-C, Fortran, Ada, Go, and D等编程语言。很多开源项目，包括 Linux kernel 和 GNU 工具，都是使用 GCC 进行编译的。本文主要为大家讲解如何在 Ubuntu 20.04 上安装 GCC。</p></blockquote><p>GNU 编译器集合是一系列用于语言开发的编译器和库的集合，包括: C, C++, Objective-C, Fortran, Ada, Go, and D等编程语言。很多开源项目，包括 Linux kernel 和 GNU 工具，都是使用 GCC 进行编译的。<br>本文描述如何在 Ubuntu 20.04 上安装 GCC。</p><h2 id="在-Ubuntu-20-04-上安装-GCC"><a href="#在-Ubuntu-20-04-上安装-GCC" class="headerlink" title="在 Ubuntu 20.04 上安装 GCC"></a>在 Ubuntu 20.04 上安装 GCC</h2><p>默认的 Ubuntu 软件源包含了一个软件包组，名称为 “build-essential”,它包含了 GNU 编辑器集合，GNU 调试器，和其他编译软件所必需的开发库和工具。</p><p>想要安装开发工具软件包，以 拥有 sudo 权限用户身份或者 root 身份运行下面的命令：</p><pre><code class="shell">sudo apt updatesudo apt install build-essential</code></pre><p>这个命令将会安装一系列软件包，包括<code>gcc</code>,<code>g++</code>,和<code>make</code>。<br>你可能还想安装关于如何使用 GNU/Linux开发的手册。</p><pre><code class="shell">sudo apt-get install manpages-dev</code></pre><p>通过运行下面的命令，打印 GCC 版本，来验证 GCC 编译器是否被成功地安装。</p><pre><code class="shell">gcc --version</code></pre><p>在 Ubuntu 20.04 软件源中 GCC 的默认可用版本号为<code>9.3.0</code>:</p><pre><code class="shell">gcc (Ubuntu 9.3.0-10ubuntu2) 9.3.0Copyright (C) 2019 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><p>就这些。GCC 已经在你的 Ubuntu 系统上安装好了，你可以开始使用它了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cron 表达式生成规则</title>
      <link href="/2021/11/18/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99/"/>
      <url>/2021/11/18/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Cron-表达式生成规则"><a href="#Cron-表达式生成规则" class="headerlink" title="Cron 表达式生成规则"></a>Cron 表达式生成规则</h1><h2 id="一、明确每个位置代表的含义"><a href="#一、明确每个位置代表的含义" class="headerlink" title="一、明确每个位置代表的含义"></a>一、明确每个位置代表的含义</h2><p>从左至右，依次表示：</p><center> 秒 &emsp; 分 &emsp; 时 &emsp; 日 &emsp; 月 &emsp; 周 &emsp; 年 </center><p>通配符一般使用 <code>*</code>，也可以使用 <code>_</code> 或者 <code>/</code>，周的位置一般用 <code>?</code></p><h2 id="二、生成规则"><a href="#二、生成规则" class="headerlink" title="二、生成规则"></a>二、生成规则</h2><h3 id="2-1-从-x-时间开始，每隔-y-时间执行一次，则在对应的位置上写上：x-y；"><a href="#2-1-从-x-时间开始，每隔-y-时间执行一次，则在对应的位置上写上：x-y；" class="headerlink" title="2.1 从 x 时间开始，每隔 y 时间执行一次，则在对应的位置上写上：x/y；"></a>2.1 从 x 时间开始，每隔 y 时间执行一次，则在对应的位置上写上：x/y；</h3><pre><code class="shell"># 从 0 分钟开始，每 5 分钟执行一次，表达式为：0 0/5 * * * ? *# 从上午 10 点开始，每 3 个小时执行一次，表达式为：0 0 10/3 * * ? *</code></pre><h3 id="2-2-定点执行，在对应的位置上写对应的数值即可"><a href="#2-2-定点执行，在对应的位置上写对应的数值即可" class="headerlink" title="2.2 定点执行，在对应的位置上写对应的数值即可"></a>2.2 定点执行，在对应的位置上写对应的数值即可</h3><pre><code class="shell"># 每天 5 点定时执行一次，表达式为：0 0 5 * * ? *# 在每个小时的 25 执行一次，表达式为：0 25 * * * ? *</code></pre><h3 id="2-3-从-x-时间到-y-时间段执行，在对应的位置上写上：x-y"><a href="#2-3-从-x-时间到-y-时间段执行，在对应的位置上写上：x-y" class="headerlink" title="2.3 从 x 时间到 y 时间段执行，在对应的位置上写上：x-y"></a>2.3 从 x 时间到 y 时间段执行，在对应的位置上写上：x-y</h3><pre><code class="shell"># 每天上午 11 点到下午 2 点执行，表达式为：0 0 11-14 * * ? *# 每个小时的 15 分到 30 分执行，表达式为：0 15-30 * * * ? *</code></pre><h3 id="2-4-关于指定时间执行的表达式，规矩很简单，只需要在对应的时间上写上要指定的时间值就可以了，中间有英文的逗号-隔开即可，这里不再举例。可根据实际情况进行组合。"><a href="#2-4-关于指定时间执行的表达式，规矩很简单，只需要在对应的时间上写上要指定的时间值就可以了，中间有英文的逗号-隔开即可，这里不再举例。可根据实际情况进行组合。" class="headerlink" title="2.4 关于指定时间执行的表达式，规矩很简单，只需要在对应的时间上写上要指定的时间值就可以了，中间有英文的逗号 , 隔开即可，这里不再举例。可根据实际情况进行组合。"></a>2.4 关于指定时间执行的表达式，规矩很简单，只需要在对应的时间上写上要指定的时间值就可以了，中间有英文的逗号 <code>,</code> 隔开即可，这里不再举例。可根据实际情况进行组合。</h3><pre><code class="shell"># 每天上午 11 点 15-11 点 45 分执行，表达式为：0 15-45 11 * * ? *# 每天上午 10 点到下午 3 点，从 15 分钟开始，每 30 分钟执行一次，表达式为：0 15/30 10-15 * * ? *</code></pre><p> 住：</p><p>1、在没有指定的位置上，前面的位置以 0 代替，后面的位置以通配符代替。</p><pre><code class="shell"># 反例：从 15 分开始，没 30 分钟执行一次。* 15/30 * * * ? *# 此时因为秒的位置是通配符，会理解为任意秒都可以执行，与预期的不符合</code></pre><p>2、针对生成规则 <strong>2.1</strong>，执行的时间是<strong>以后面的我基准</strong>的。</p><pre><code class="shell"># 例：* 15/25 10-23 * * ? *# 当前时间设为 16:20，则前 5 次的执行时间为：16:40:0017:15:0017:40:0018:15:0018:40:00# 表达式的含义为：每天 10 点 到 23 点，从每点的 15 分开始，每 25 分钟执行一次。</code></pre><p>因为当前时间为 16:20，所以第一次执行时间会从 16 点 15 分开始算起，每 25 分钟执行一次。</p><p>因为当前时间为 16:20，所以第一次执行时间回仓 16 点 15 分开始算起，由于已经过了 16:15，所以往后推算 25 分钟，是 16:40，所以，第一次执行时间是 16:40。</p><p>有人可能会以为第二次执行的时间会是 17:05。这样算是不对的。因为 16:40 往后推算 25 分钟超过了 17 点，所以下一次的应该是以 17 点算起，从 17 点 15 开始执行第二次。一次类推。这就是 “以后面的为基准” 的意思。</p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看Linux发行版本信息</title>
      <link href="/2021/11/18/%E6%9F%A5%E7%9C%8BLinux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/"/>
      <url>/2021/11/18/%E6%9F%A5%E7%9C%8BLinux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="查看Linux发行版本信息"><a href="#查看Linux发行版本信息" class="headerlink" title="查看Linux发行版本信息"></a>查看Linux发行版本信息</h1><p><strong>linux下如何查看已安装的centos版本信息：</strong></p><p><strong>CentOS</strong></p><pre><code class="shell"># 方法一cat /etc/centos-release# 示例结果CentOS Linux release 7.6.1810 (AltArch)</code></pre><p><strong>Ubuntu</strong></p><pre><code class="shell">cat /etc/issue# 示例结果Ubuntu 20.04.2 LTS \n \l</code></pre><p><strong>其他所有</strong></p><pre><code class="shell">lsb_release -a# 示例结果LSB Version:    n/aDistributor ID: SUSEDescription:    SUSE Linux Enterprise Server 12 SP4Release:        12.4Codename:       n/a</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看处理器是X86还是ARM架构的</title>
      <link href="/2021/11/18/%E6%9F%A5%E7%9C%8B%E5%A4%84%E7%90%86%E5%99%A8%E6%98%AFX86%E8%BF%98%E6%98%AFARM%E6%9E%B6%E6%9E%84%E7%9A%84/"/>
      <url>/2021/11/18/%E6%9F%A5%E7%9C%8B%E5%A4%84%E7%90%86%E5%99%A8%E6%98%AFX86%E8%BF%98%E6%98%AFARM%E6%9E%B6%E6%9E%84%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="查看处理器是X86还是ARM架构的"><a href="#查看处理器是X86还是ARM架构的" class="headerlink" title="查看处理器是X86还是ARM架构的"></a>查看处理器是X86还是ARM架构的</h1><pre><code class="shell">file $SHELL或arch</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据进程的PID值来查找执行文件及其路径</title>
      <link href="/2021/11/18/%E6%A0%B9%E6%8D%AE%E8%BF%9B%E7%A8%8B%E7%9A%84PID%E5%80%BC%E6%9D%A5%E6%9F%A5%E6%89%BE%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/11/18/%E6%A0%B9%E6%8D%AE%E8%BF%9B%E7%A8%8B%E7%9A%84PID%E5%80%BC%E6%9D%A5%E6%9F%A5%E6%89%BE%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%B6%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="根据进程的PID值来查找执行文件及其路径"><a href="#根据进程的PID值来查找执行文件及其路径" class="headerlink" title="根据进程的PID值来查找执行文件及其路径"></a>根据进程的PID值来查找执行文件及其路径</h1><pre><code class="shell">lsof -p &lt;PID&gt;pwdx PID</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序自愈脚本</title>
      <link href="/2021/11/18/%E7%A8%8B%E5%BA%8F%E8%87%AA%E6%84%88%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/11/18/%E7%A8%8B%E5%BA%8F%E8%87%AA%E6%84%88%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="程序自愈脚本"><a href="#程序自愈脚本" class="headerlink" title="程序自愈脚本"></a>程序自愈脚本</h1><p><strong>1、编写脚本 ato_start.sh</strong></p><pre><code class="shell"># ! /bin/sh                          procnum=`ps -ef| grep  进程名(如agent70)|grep -v grep| grep -v vi| grep -v cat | wc -l`echo $procnum   if [ $procnum -eq 0 ]   then      cd  /app/toptea/ccp/hub/bin      sh  start.sh      echo `date +%Y-%m-%d` `date +%H:%M:%S`  &quot;auto_start_进程 process!&quot; &gt;&gt;/app/toptea/ccp/hub/log/ato_start_log.logfi</code></pre><p><strong>2、编写 cron 定时任务</strong></p><pre><code class="shell">*/1   * * * *  sh /app/toptea/ccp/hub/ato_start.sh</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次使用gcc命令时报错：gcc未找到命令</title>
      <link href="/2021/11/18/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gcc%E5%91%BD%E4%BB%A4%E6%97%B6%E6%8A%A5%E9%94%99%EF%BC%9Agcc%E6%9C%AA%E6%89%BE%E5%88%B0%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/18/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8gcc%E5%91%BD%E4%BB%A4%E6%97%B6%E6%8A%A5%E9%94%99%EF%BC%9Agcc%E6%9C%AA%E6%89%BE%E5%88%B0%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次使用gcc命令时报错：gcc未找到命令"><a href="#第一次使用gcc命令时报错：gcc未找到命令" class="headerlink" title="第一次使用gcc命令时报错：gcc未找到命令"></a>第一次使用gcc命令时报错：gcc未找到命令</h1><p>（1）查看是否安装了gcc相关程序</p><pre><code class="shell"># 命令which gcc</code></pre><p>（显示没有相关文件）</p><p>（2）安装gcc程序</p><pre><code class="shell"># 命令yum -y install gcc automake autoconf libtool make</code></pre><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Linux &amp;&amp; Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
